# coding: utf-8

# ほげ

require 'active_support/inflector'
require 'pathname'

$LOAD_PATH << __dir__
require 'tmx'
begin
  require 'master'
  require 'game'
rescue LoadError
  nil
end

#===================================================
# 定数
#===================================================

PROJECT_ROOT = Pathname.new('..')
DATA_DIR = Pathname.new('.')
OUTPUT = DATA_DIR + 'Output'
TEMP = DATA_DIR + 'Temp'
PROTO_DIR = PROJECT_ROOT + 'Tools/Protocols'

if RUBY_PLATFORM =~ /darwin/
  CFSCTL = '../Tools/Bin/cfsctl'
  PROTOC = 'protoc'
else
  CFSCTL = '../Tools/Bin/cfsctl.exe'
  PROTOC = '../Tools/Bin/protoc.exe' # './Tools/Bin/protoc'
end

mkdir_p [OUTPUT, TEMP], verbose: false

#===================================================
# 便利関数
#===================================================

# String#pathmap にもとづいて、タスクを作成して、出力ファイルのリストを取得する
#
# 使用例:
# OUT = map_task(['a.txt', 'b.txt'], 'out/%n.bin') do |t|
#   puts t.source
# end
# OUT # => ['out/a.bin', 'out/b.bin']
def pathmap_task(filelist, pathmap_pattern)
  raise "pathmap_pattern must be String but #{pathmap_pattern.class}" unless pathmap_pattern.is_a? String
  filelist.map do |src|
    out = src.pathmap(pathmap_pattern)
    file out => src do |t|
      yield t
    end
    out
  end
end

# rubocop:disable Style/GlobalVars
def logger
  unless $_logger
    $_logger = Logger.new(STDOUT)
    $_logger.level = Logger::ERROR
  end
  $_logger
end
# rubocop:enable Style/GlobalVars

# Inflectorに単語登録
ActiveSupport::Inflector.inflections do |inf|
  inf.singular 'bonus', 'bonus'
  inf.singular 'data', 'data'
end

#===================================================
# タスクリスト
#===================================================

task :default => [:map, :master]

task :clean do
  rm_rf OUTPUT
end

desc 'protoファイルからプロトコルを作成する'
task :proto do
  mkdir_p __dir__ + "/autogen"
  FileList[PROTO_DIR + '*.proto'].each do |proto|
    sh PROTOC,
       "--ruby_out=#{PROJECT_ROOT}/Tools/Converter/autogen",
       "--proto_path=#{PROTO_DIR}",
       proto.to_s
    sh PROTOC,
       "--plugin=#{PROJECT_ROOT}/Tools/Bin/protoc-gen-dfcsharp",
       "--dfcsharp_out=#{PROJECT_ROOT}/Client/Assets/Scripts/AutoGenerated/",
       "--proto_path=#{PROTO_DIR}",
       proto.to_s
  end
end

OUT_MAPS = pathmap_task(FileList[DATA_DIR + '*.tmx'], OUTPUT.to_s + '/%n-Stage.pb') do |t|
  logger.info "Converting #{t.source}"
  map = Tmx.new(t.source)
  IO.binwrite(t.name, map.dump_pb)
end

desc 'マップファイルの変換'
task :map => OUT_MAPS

OUT_EXLS = pathmap_task(FileList[DATA_DIR + 'Master/**/*.xls'], OUTPUT.to_s + '/%n.touch') do |t|
  logger.info "Converting #{t.source}"
  IO.write(t.name, t.source)

  # model_name = 'CharacterTemplate'
  # model_sheet = 'CharacterTemplate'
  # model_class = Master.const_get(model_name.classify)
  # PbConvert.conv_master(s.name, s.source, model_sheet, model_class)
end

desc 'マスターファイルの変換'
task :master => OUT_EXLS

desc 'アップロード'
task :upload do
  sh "#{CFSCTL} upload -t tb-dev -b client.bucket Output"
  client_hash = IO.read('client.bucket.hash')

  host = 'http://133.242.235.150:7000'
  tag = 'tb-dev'
  require 'net/http'
  res = Net::HTTP.post_form(URI.parse("#{host}/tags/#{tag}"),
                            'val' => client_hash)
  raise "upload failed! #{res}" unless res.is_a? Net::HTTPSuccess

  #
  #   if ENV['SITE_URL']
  #     begin
  #       site = ENV['SITE_URL']
  #       param = {cfs_hash_client: client_hash, cfs_hash_server: server_hash}
  #       res = Net::HTTP.post_form( URI.parse(site) + '/update_cfs', param)
  #       logger.info "upload to '#{site}', hash=#{client_hash}, sv_hash=#{server_hash}"
  #       if res.body.include?("error")
  #         logger.error "response: #{res.body}"
  #       else
  #         logger.info "response: #{res.body}"
  #       end
  #     rescue Errno::ECONNREFUSED
  #       logger.error "サーバに接続できません。URL='#{site}'"
  #     end
  #   else
  #     logger.warn 'environment variable "SITE_URL" is not specified! server setting is not updated.'
  #     logger.warn 'example, $ SITE_URL=http://localhost:3000/ rake upload'
  #   end
end
