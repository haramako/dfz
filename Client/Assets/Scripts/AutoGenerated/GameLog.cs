// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: game_log.proto
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using System.Collections.Generic;
using pb = global::Google.ProtocolBuffers;
using scg = global::System.Collections.Generic;
namespace GameLog {

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public static partial class GameLog {

  }
  #region Messages
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class Walk : pb.Message {
    private Walk() { }
    public static Walk CreateInstance() { var obj = new Walk(); obj.Finish(); return obj; }
    public static Walk CreateEmpty() { return new Walk(); }
    private static readonly Walk defaultInstance = new Walk();
    public static Walk DefaultInstance {
      get { return defaultInstance; }
    }

    public int CharacterId;

    public int X;

    public int Y;

    #region Lite runtime methods
    #endregion

    public override void WriteTo(pb::CodedOutputStream output) {
      CalcSerializedSize();
      if (CharacterId != 0) {
        output.WriteInt32(1, CharacterId);
      }
      if (X != 0) {
        output.WriteInt32(2, X);
      }
      if (Y != 0) {
        output.WriteInt32(3, Y);
      }
    }

    public override int SerializedSize {
      get {
        return CalcSerializedSize();
      }
    }

    private int CalcSerializedSize() {
      int size = 0;
      if (CharacterId != 0) {
        size += pb::CodedOutputStream.ComputeInt32Size(1, CharacterId);
      }
      if (X != 0) {
        size += pb::CodedOutputStream.ComputeInt32Size(2, X);
      }
      if (Y != 0) {
        size += pb::CodedOutputStream.ComputeInt32Size(3, Y);
      }
      return size;
    }
    public static Walk ParseFrom(byte[] data) {
      var mes = CreateInstance(); mes.MergeFrom(data); return mes;
    }
    public static Walk ParseFrom(global::System.IO.Stream input) {
      var mes = CreateInstance(); mes.MergeFrom(input); return mes;
    }
    public static Walk ParseFrom(pb::CodedInputStream input) {
      var mes = CreateInstance(); mes.MergeFrom(input); return mes;
    }
    public override void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while (input.ReadTag(out tag)) {
        switch (tag) {
          case 0: {
            throw pb::InvalidProtocolBufferException.InvalidTag();
          }
          default: {
            if (pb::WireFormat.IsEndGroupTag(tag)) {
              return;
            }
            break;
          }
          case 8: {
            input.ReadInt32(ref this.CharacterId);
            break;
          }
          case 16: {
            input.ReadInt32(ref this.X);
            break;
          }
          case 24: {
            input.ReadInt32(ref this.Y);
            break;
          }
        }
      }
    }

    public override void Init() {
    }
    public override void Finish() {
    }
  }

  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class WalkOrder : pb.Message {
    private WalkOrder() { }
    public static WalkOrder CreateInstance() { var obj = new WalkOrder(); obj.Finish(); return obj; }
    public static WalkOrder CreateEmpty() { return new WalkOrder(); }
    private static readonly WalkOrder defaultInstance = new WalkOrder();
    public static WalkOrder DefaultInstance {
      get { return defaultInstance; }
    }

    public int CharacterId;

    public int FromX;

    public int FromY;

    public int ToX;

    public int ToY;

    #region Lite runtime methods
    #endregion

    public override void WriteTo(pb::CodedOutputStream output) {
      CalcSerializedSize();
      if (CharacterId != 0) {
        output.WriteInt32(1, CharacterId);
      }
      if (FromX != 0) {
        output.WriteInt32(2, FromX);
      }
      if (FromY != 0) {
        output.WriteInt32(3, FromY);
      }
      if (ToX != 0) {
        output.WriteInt32(4, ToX);
      }
      if (ToY != 0) {
        output.WriteInt32(5, ToY);
      }
    }

    public override int SerializedSize {
      get {
        return CalcSerializedSize();
      }
    }

    private int CalcSerializedSize() {
      int size = 0;
      if (CharacterId != 0) {
        size += pb::CodedOutputStream.ComputeInt32Size(1, CharacterId);
      }
      if (FromX != 0) {
        size += pb::CodedOutputStream.ComputeInt32Size(2, FromX);
      }
      if (FromY != 0) {
        size += pb::CodedOutputStream.ComputeInt32Size(3, FromY);
      }
      if (ToX != 0) {
        size += pb::CodedOutputStream.ComputeInt32Size(4, ToX);
      }
      if (ToY != 0) {
        size += pb::CodedOutputStream.ComputeInt32Size(5, ToY);
      }
      return size;
    }
    public static WalkOrder ParseFrom(byte[] data) {
      var mes = CreateInstance(); mes.MergeFrom(data); return mes;
    }
    public static WalkOrder ParseFrom(global::System.IO.Stream input) {
      var mes = CreateInstance(); mes.MergeFrom(input); return mes;
    }
    public static WalkOrder ParseFrom(pb::CodedInputStream input) {
      var mes = CreateInstance(); mes.MergeFrom(input); return mes;
    }
    public override void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while (input.ReadTag(out tag)) {
        switch (tag) {
          case 0: {
            throw pb::InvalidProtocolBufferException.InvalidTag();
          }
          default: {
            if (pb::WireFormat.IsEndGroupTag(tag)) {
              return;
            }
            break;
          }
          case 8: {
            input.ReadInt32(ref this.CharacterId);
            break;
          }
          case 16: {
            input.ReadInt32(ref this.FromX);
            break;
          }
          case 24: {
            input.ReadInt32(ref this.FromY);
            break;
          }
          case 32: {
            input.ReadInt32(ref this.ToX);
            break;
          }
          case 40: {
            input.ReadInt32(ref this.ToY);
            break;
          }
        }
      }
    }

    public override void Init() {
    }
    public override void Finish() {
    }
  }

  #endregion

}

#endregion Designer generated code
